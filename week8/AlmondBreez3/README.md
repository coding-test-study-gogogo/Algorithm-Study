
# 양궁 대회 문제 해결 개선 가이드

이 README는 양궁 대회 문제 해결을 위한 코드 개선 방안을 설명합니다. 기존 코드와 최적화된 정답 코드를 비교하여 주요 차이점과 개선 방안을 제시합니다.

## 주요 개선 사항

1. **자료구조 선택**
    - 현재: HashMap과 boolean 배열 사용
    - 개선: 단순 정수 배열 사용
    - 이점: 메모리 사용량 및 접근 시간 감소

2. **DFS 구현**
    - 현재: 모든 점수에 대해 반복, visited 배열 사용
    - 개선: 인덱스 기반 접근, 점수 획득/포기 두 경우만 고려
    - 이점: 불필요한 반복 감소, 로직 단순화

3. **점수 계산 방식**
    - 현재: 복잡한 조건문 사용
    - 개선: 단순화된 조건문 사용
    - 이점: 계산 속도 향상

4. **최대 점수 차이 처리**
    - 현재: curDiff와 curMax 사용, 복잡한 비교 로직
    - 개선: curDiff만 사용, isLowerScoreBetter() 메소드로 동점 처리
    - 이점: 로직 단순화 및 명확성 증가

5. **남은 화살 처리**
    - 현재: 처리 로직 없음
    - 개선: DFS 내에서 남은 화살을 가장 낮은 점수에 할당
    - 이점: 모든 화살 사용 보장

6. **결과 업데이트**
    - 현재: for 루프로 결과 복사
    - 개선: System.arraycopy() 사용
    - 이점: 배열 복사 성능 향상

7. **초기값 설정**
    - 현재: curDiff를 Integer.MAX_VALUE로 초기화
    - 개선: curDiff를 0으로 초기화
    - 이점: 문제 조건에 맞는 초기값 설정

8. **코드 구조**
    - 현재: 복잡한 구조, 여러 메서드와 변수 사용
    - 개선: 간결하고 명확한 구조
    - 이점: 코드 가독성 및 유지보수성 향상

## 결론

양궁대회 문제의 시간 복잡도를 계산하기 위해, 문제를 해결하는 방식(DFS, 백트래킹)의 구조를 살펴보겠습니다.

### 문제 설명

이 문제는 라이언이 화살을 배치하여 어피치보다 높은 점수를 얻기 위해 가능한 화살의 배치를 찾는 문제입니다. 각 점수는 0~10점이고, 라이언과 어피치는 이 점수들을 두고 경쟁합니다. 라이언이 화살을 할당할 수 있는 경우의 수는 매우 많으며, 이를 효율적으로 탐색해야 합니다.

### DFS와 백트래킹 기반 풀이

이 문제의 풀이는 DFS(깊이 우선 탐색)와 백트래킹을 활용합니다. DFS를 사용하여 11개의 점수 구간(10점부터 0점까지)에 라이언의 화살을 어떻게 배치할지 모든 경우의 수를 탐색합니다. 각 점수 구간에서 두 가지 선택지가 존재합니다:
1. 라이언이 그 점수에서 이기는 경우 (라이언의 화살 수가 어피치보다 하나 더 많음).
2. 라이언이 그 점수에서 지거나 화살을 사용하지 않는 경우.

이 DFS 방식에서 각 단계에서 두 가지 선택지를 탐색하기 때문에 이진 트리와 같은 형태로 DFS가 진행됩니다.

### DFS의 최대 깊이와 경우의 수

이 문제에서 DFS의 최대 깊이는 11입니다(10점부터 0점까지의 점수). 각 점수에 대해 라이언이 화살을 배치할지, 아니면 넘길지를 결정하므로, 각 깊이에서 두 가지 선택지가 있습니다.

따라서 DFS의 시간 복잡도는 `O(2^11)`과 같습니다.

#### 하지만 화살 개수 제한이 존재

라이언이 가질 수 있는 화살 개수는 `n`으로 주어집니다. 화살이 모두 사용되면 더 이상 화살을 배치할 수 없으므로 경우의 수가 줄어들게 됩니다. 그러나 이 제한이 있다고 하더라도, 화살의 개수 `n`이 점수 구간보다 작다면 화살을 배치하는 모든 경우를 탐색해야 하므로 여전히 시간 복잡도는 `O(2^11)`에 가깝습니다.

### 정리된 시간 복잡도

- 점수 구간: 11개 (0 ~ 10점)
- 각 구간에서 2가지 선택: 라이언이 이기거나 지는 선택

따라서, DFS의 경우의 수는 `2^11 = 2048`입니다. 여기에 각 경우에서 점수를 계산하는 데 `O(11)`의 시간이 걸리므로, 전체 시간 복잡도는 다음과 같습니다:

**시간 복잡도 = O(11 * 2^11) = O(2048 * 11) = O(22528)**

### 최종 결론

양궁대회 문제의 시간 복잡도는 **O(2^11)** 정도로 계산할 수 있으며, 이는 매우 큰 숫자가 아니므로 시간 내에 충분히 해결 가능한 수준입니다.

백트래킹을 통해 불필요한 탐